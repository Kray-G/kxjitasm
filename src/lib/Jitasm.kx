

using @kacc.Lexer;

const YYERRTOK = 256;
const LOAD = 257;
const DATA = 258;
const STR = 259;
const CMD = 260;
const FUNC = 261;
const LIB = 262;
const LABEL = 263;
const IF = 264;
const JMP = 265;
const CALL = 266;
const RET = 267;
const FMOV32 = 268;
const FMOV = 269;
const MOV8S = 270;
const MOV16S = 271;
const MOV32S = 272;
const MOV8 = 273;
const MOV16 = 274;
const MOV32 = 275;
const MOV = 276;
const NOT32 = 277;
const NEG32 = 278;
const CLZ32 = 279;
const NOT = 280;
const NEG = 281;
const CLZ = 282;
const ADD32 = 283;
const SUB32 = 284;
const MUL32 = 285;
const DIV32 = 286;
const SDIV32 = 287;
const MOD32 = 288;
const SMOD32 = 289;
const AND32 = 290;
const OR32 = 291;
const XOR32 = 292;
const SHL32 = 293;
const LSHR32 = 294;
const ASHR32 = 295;
const ADD = 296;
const SUB = 297;
const MUL = 298;
const DIV = 299;
const SDIV = 300;
const MOD = 301;
const SMOD = 302;
const AND = 303;
const OR = 304;
const XOR = 305;
const SHL = 306;
const LSHR = 307;
const ASHR = 308;
const EQ = 309;
const NEQ = 310;
const GE = 311;
const LE = 312;
const GT = 313;
const LT = 314;
const SGE = 315;
const SLE = 316;
const SGT = 317;
const SLT = 318;
const SREG = 319;
const RREG = 320;
const VAR = 321;
const ARG = 322;
const INT = 323;
const DBL = 324;
const SIGNED = 325;
const OPEQ = 326;
const OPNEQ = 327;
const OPGE = 328;
const OPLE = 329;

namespace Kacc {

/* Prototype file of Kinx parser.
 * Written by Kray-G
 * This file is PUBLIC DOMAIN.
 */

class Parser(lexer_, opts_) {

    /*
    #define yyclearin (yychar = -1)
    #define yyerrok (yyerrflag = 0)
    #define YYRECOVERING (yyerrflag != 0)
    #define YYERROR  goto yyerrlab
    */

    var value_;
    var yyerror = opts_.yyerror ?? System.println;

    private initialize() {
        opts_.keySet().each {
            if (opts_[_1].isFunction) {
                this[_1] = opts_[_1];
            }
        };
    }

    private yyprintln(msg) {
        System.println(msg);
    }

    /* Debug mode flag */
    @yydebug = false;


    const yytranslate = [
            0,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           21,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   29,   26,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   22,   30,
           24,   30,   25,   30,   23,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   27,   30,   28,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,    1,    2,   30,    3,
            4,    5,    6,    7,    8,    9,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
           30,   30,   30,   30,   30,   30,   30,   30,   30,   10,
           11,   12,   13,   14,   15,   16,   17,   18,   19,   20
    ];

    const YYBADCH = 30;
    const YYMAXLEX = 330;
    const YYTERMS = 30;
    const YYNONTERMS = 11;

    const yyaction = [
           25,   19,  108,    3,   26,   61,   27,    2,   28,  100,
           32,   33,   92,   93,   34,   35,   96,   97,   22,   23,
           74,   84,   29,   85,   65,   36,   -1,    0,  109,   20,
            6,    7,    8,    9,   12,   13,  110,   10,   11,   14,
           15,  106,   24,  105,  104,  111,  113,  101,   80,   79,
          112,   41,  107,   18,   39,   40,   78,   62,   63,   64,
           66,   67,   68,   69,   59,   60,    0,    0,    0,    0,
            0,  103,   44,   86,   45,   87,    0,    0,    4,    0,
            0,    0,    0,    0,   75,   76,   77,   82,   83,    0,
            0,    0,    0,    0,    5,    0,   42,   43,    0,   95,
           94,   99,   98,    0,   46
    ];

    const YYLAST = 105;

    const yycheck = [
            1,    2,    7,    4,    5,    9,    7,    8,    9,    7,
            5,    6,   10,   11,   12,   13,   14,   15,   10,   11,
           21,    3,   23,   25,   26,   23,    0,    0,    7,   27,
           17,   18,   19,   20,   19,   20,    7,   24,   25,   24,
           25,    7,   24,    7,    7,    7,    7,    7,    7,    7,
            7,    7,    7,    7,    7,   22,   21,    9,    9,    9,
            9,    9,    9,    9,    9,    9,   -1,   -1,   -1,   -1,
           -1,   14,   14,   14,   14,   14,   -1,   -1,   16,   -1,
           -1,   -1,   -1,   -1,   21,   21,   21,   21,   21,   -1,
           -1,   -1,   -1,   -1,   26,   -1,   27,   27,   -1,   28,
           28,   28,   28,   -1,   29
    ];

    const yybase = [
           -1,   26,   62,    2,    2,    2,    2,    2,    2,    2,
            2,    2,    2,    2,    2,    2,   13,   15,   18,    5,
            8,   -2,   75,   75,   59,   67,   47,   33,   44,   46,
           27,   66,   42,   41,   69,   70,   40,   65,   68,   64,
           63,   35,   58,   60,   74,   73,   57,   72,   71,   55,
           56,   -4,   48,   49,   50,   51,   52,   53,   54,   37,
           36,   34,   45,   21,   -5,   61,   29,   38,   39,   43,
            0,   -1,    2
    ];

    const YY2TBLSTATE = 3;

    const yydefault = [
        32767,32767,32767,   18,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,
        32767,32767,   32,   32,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,   19,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767
    ];

    const yygoto = [
           90,   17,   91,   49,   50,   51,   52,   53,   54,   55,
           56,   57,   58,   73,   48
    ];

    const YYGLAST = 15;

    const yygcheck = [
            9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
            9,    9,    9,    3,   10
    ];

    const yygbase = [
            0,    0,    0,   12,    0,    0,    0,    0,    0,   -3,
           -9
    ];

    const yygdefault = [
        -32768,   30,    1,   72,   37,   81,   31,   21,   38,   16,
           47
    ];

    const yylhs = [
            0,    1,    2,    2,    3,    3,    3,    3,    3,    3,
            3,    3,    3,    3,    5,    5,    7,    7,    4,    4,
            8,    8,    9,    9,    9,    9,    9,    9,    9,    9,
            9,    9,   10,   10,    6,    6,    6,    6,    6,    6,
            6,    6,    6,    6
    ];

    const yylen = [
            1,    1,    1,    2,    1,    3,    3,    3,    3,    3,
            3,    3,    2,    2,    1,    3,    1,    3,    0,    1,
            1,    3,    1,    1,    4,    4,    1,    1,    4,    4,
            1,    2,    0,    2,    6,    6,    6,    6,    6,    6,
            7,    7,    7,    7
    ];

    const YYSTATES = 109;
    const YYNLSTATES = 70;
    const YYINTERRTOK = 1;
    const YYUNEXPECTED = 32767;
    const YYDEFAULT = -32766;

    var yylex = lexer_.yylex;

    /*
     * Parser entry point
     */
    private yyparse() {
        var yyastk = [];
        var yysstk = [];
        var yylval, yyn, yysp = 0;
        var yyerrflag = 0;
        var yyval;

        yystate = 0;
        yychar = -1;
        yysstk[yysp] = 0;

        while (true) {
            if (yybase[yystate] == 0)
                yyn = yydefault[yystate];
            else {
                if (yychar < 0) {
                    yylval = {};
                    if ((yychar = yylex(yylval)) <= 0) yychar = 0;
                    yychar = yychar < YYMAXLEX ? yytranslate[yychar] : YYBADCH;
                }

                if (((yyn = yybase[yystate] + yychar) >= 0
                    && yyn < YYLAST && yycheck[yyn] == yychar
                    || (yystate < YY2TBLSTATE
                        && (yyn = yybase[yystate + YYNLSTATES] + yychar) >= 0
                        && yyn < YYLAST && yycheck[yyn] == yychar))
                    && (yyn = yyaction[yyn]) != YYDEFAULT) {
                    /*
                     * >= YYNLSTATE: shift and reduce
                     * > 0: shift
                     * = 0: accept
                     * < 0: reduce
                     * = -YYUNEXPECTED: error
                     */
                    if (yyn > 0) {
                        /* shift */
                        yysp++;

                        yysstk[yysp] = yystate = yyn;
                        yyastk[yysp] = yylval;
                        yychar = -1;

                        if (yyerrflag > 0)
                            yyerrflag--;
                        if (yyn < YYNLSTATES)
                            continue;

                        /* yyn >= YYNLSTATES means shift-and-reduce */
                        yyn -= YYNLSTATES;
                    } else {
                        yyn = -yyn;
                    }
                } else {
                    yyn = yydefault[yystate];
                }
            }

            while (true) {
                /* reduce/error */
                if (yyn == 0) {
                    /* accept */
                    value_ = yyastk[yysp];
                    return 0;
                } else if (yyn != YYUNEXPECTED) {
                    /* reduce */
                    yyl = yylen[yyn];
                    yyval = yyastk[yysp-yyl+1];
                    /* Following line will be replaced by reduce actions */
                    switch(yyn) {
                    case 2:
{ yyastk[yysp-(1-1)].line = @getLine(); yyval = [yyastk[yysp-(1-1)]]; @nextLine(); } break;
                    case 3:
{ yyastk[yysp-(2-2)].line = @getLine(); if (yyastk[yysp-(2-2)].isDefined) yyval.push(yyastk[yysp-(2-2)]); @nextLine(); } break;
                    case 4:
{ yyval = null; } break;
                    case 5:
{ yyval = { "cmd": LABEL, "name": "label", "operand": [{ "name": yyastk[yysp-(3-1)].value }] }; } break;
                    case 6:
{ yyval = { "cmd": FUNC, "name": "func", "operand": [{ "name": yyastk[yysp-(3-2)].value }] }; } break;
                    case 7:
{ yyval = { "cmd": yyastk[yysp-(3-1)].value, "name": yyastk[yysp-(3-1)].name, "operand": yyastk[yysp-(3-2)] }; } break;
                    case 8:
{ yyval = { "cmd": JMP, "name": "jmp", "operand": [{ "name": yyastk[yysp-(3-2)].value }] }; } break;
                    case 9:
{ yyval = { "cmd": LOAD, "name": "load", "operand": [{ "type": FUNC, "name": yyastk[yysp-(3-3)].value }] }; } break;
                    case 10:
{ yyval = { "cmd": LOAD, "name": "load", "operand": [{ "type": LIB, "name": yyastk[yysp-(3-3)].value }] }; } break;
                    case 11:
{ yyval = { "cmd": DATA, "name": "data", "operand": [{ "name": yyastk[yysp-(3-2)].value, "value": yyastk[yysp-(3-3)].value }] }; } break;
                    case 13:
{ yyval.error = true; } break;
                    case 15:
{ yyval.value = <...yyastk[yysp-(3-2)]>; } break;
                    case 16:
{ yyval = [yyastk[yysp-(1-1)].value]; } break;
                    case 17:
{ yyval.push(yyastk[yysp-(3-3)].value); } break;
                    case 18:
{ yyval = []; } break;
                    case 20:
{ yyval = [yyastk[yysp-(1-1)]]; } break;
                    case 21:
{ yyval.push(yyastk[yysp-(3-3)]); } break;
                    case 22:
{ yyval = { "type": "S", "n": yyastk[yysp-(1-1)].value }; } break;
                    case 23:
{ yyval = { "type": "R", "n": yyastk[yysp-(1-1)].value }; } break;
                    case 24:
{ yyval = { "type": "DS", "n": yyastk[yysp-(4-2)].value, "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 25:
{ yyval = { "type": "DR", "n": yyastk[yysp-(4-2)].value, "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 26:
{ yyval = { "type": "I", "v": yyastk[yysp-(1-1)].value }; } break;
                    case 27:
{ yyval = { "type": "D", "v": yyastk[yysp-(1-1)].value }; } break;
                    case 28:
{ yyval = { "type": "V", "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 29:
{ yyval = { "type": "A", "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 30:
{ yyval = { "type": "L", "name": yyastk[yysp-(1-1)].value }; } break;
                    case 31:
{ yyval = { "type": "A", "name": yyastk[yysp-(2-2)].value }; } break;
                    case 32:
{ yyval.value = 0; } break;
                    case 33:
{ yyval.value = yyastk[yysp-(2-2)].value; } break;
                    case 34:
{ yyval = { "cmd": EQ, "name": "eq", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 35:
{ yyval = { "cmd": NEQ, "name": "neq", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 36:
{ yyval = { "cmd": GE, "name": "ge", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 37:
{ yyval = { "cmd": LE, "name": "le", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 38:
{ yyval = { "cmd": GT, "name": "gt", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 39:
{ yyval = { "cmd": LT, "name": "lt", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 40:
{ yyval = { "cmd": SGE, "name": "sge", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    case 41:
{ yyval = { "cmd": SLE, "name": "sle", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    case 42:
{ yyval = { "cmd": SGT, "name": "sgt", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    case 43:
{ yyval = { "cmd": SLT, "name": "slt", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    }
                    /* Goto - shift nonterminal */
                    yysp -= yyl;
                    yyn = yylhs[yyn];
                    if ((yyp = yygbase[yyn] + yysstk[yysp]) >= 0 && yyp < YYGLAST && yygcheck[yyp] == yyn)
                        yystate = yygoto[yyp];
                    else
                        yystate = yygdefault[yyn];

                    yysp++;

                    yysstk[yysp] = yystate;
                    yyastk[yysp] = yyval;
                } else {
                    /* error */
                    switch (yyerrflag) {
                    case 0:
                        yyerror("syntax error");
                    case 1:
                    case 2:
                        yyerrflag = 3;
                        /* Pop until error-expecting state uncovered */

                        while (!((yyn = yybase[yystate] + YYINTERRTOK) >= 0
                            && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK
                            || (yystate < YY2TBLSTATE
                                && (yyn = yybase[yystate + YYNLSTATES] + YYINTERRTOK) >= 0
                                && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK))) {
                            if (yysp <= 0) {
                                return 1;
                            }
                            yystate = yysstk[--yysp];
                        }
                        yyn = yyaction[yyn];
                        yysstk[++yysp] = yystate = yyn;
                        break;

                    case 3:
                        if (yychar == 0) {
                            return 1;
                        }
                        yychar = -1;
                        break;
                    }
                }

                if (yystate < YYNLSTATES)
                    break;
                /* >= YYNLSTATES means shift-and-reduce */
                yyn = yystate - YYNLSTATES;
            }
        }
    }

    this.parse = _function(text, successCallback, failureCallback) {
        lexer_.reset(text);
        if (yyparse() == 0) {
            successCallback(value_);
        } else {
            failureCallback(value_);
        }
    };

}

} // namespace Kacc


using Jit;

class Jitasm(opts_) {
    var lexer_, code_;
    var loaded_, data_, entries_, funcname_, pendings_, error_;
    var regs_ = {
        "R": [Jit.R0, Jit.R1, Jit.R2, Jit.R3, Jit.R4, Jit.R5],
        "S": [Jit.S0, Jit.S1, Jit.S2, Jit.S3, Jit.S4, Jit.S5],
        "FR": [Jit.FR0, Jit.FR1, Jit.FR2, Jit.FR3, Jit.FR4, Jit.FR5],
        "FS": [Jit.FS0, Jit.FS1, Jit.FS2, Jit.FS3, Jit.FS4, Jit.FS5],
    };

    private initialize() {
        /* Lexical analyzer */
        lexer_ = new Kacc.Lexer();
        lexer_.addSkip(/[ \t\r]+|#[^\r\n]+/);
        lexer_.addKeyword("load", LOAD);
        lexer_.addKeyword("==", OPEQ);
        lexer_.addKeyword("!=", OPNEQ);
        lexer_.addKeyword(">=", OPGE);
        lexer_.addKeyword("<=", OPLE);
        lexer_.addKeyword("if", IF);
        lexer_.addKeyword("signed", SIGNED);
        lexer_.addKeyword("func", FUNC);
        lexer_.addKeyword("lib", LIB);
        lexer_.addKeyword("var", VAR);
        lexer_.addKeyword("arg", ARG);
        lexer_.addKeyword("goto", JMP) { &(yylval, token)
            yylval.value = JMP;
            yylval.name = "jmp";
            return token;
        };
        [
            { "value": JMP,    "name": "jmp"       },
            { "value": CALL,   "name": "call"      },
            { "value": RET,    "name": "ret"       },

            { "value": MOV8S,  "name": "mov8s"     },
            { "value": MOV16S, "name": "mov16s"    },
            { "value": MOV32S, "name": "mov32s"    },
            { "value": MOV8,   "name": "mov8"      },
            { "value": MOV16,  "name": "mov16"     },
            { "value": MOV32,  "name": "mov32"     },
            { "value": MOV,    "name": "mov"       },
            { "value": FMOV32, "name": "fmov32"    },
            { "value": FMOV,   "name": "fmov"      },

            { "value": NOT32,  "name": "not32"     },
            { "value": NEG32,  "name": "neg32"     },
            { "value": CLZ32,  "name": "clz32"     },
            { "value": NOT,    "name": "not"       },
            { "value": NEG,    "name": "neg"       },
            { "value": CLZ,    "name": "clz"       },

            { "value": ADD32,  "name": "add32"     },
            { "value": SUB32,  "name": "sub32"     },
            { "value": MUL32,  "name": "mul32"     },
            { "value": DIV32,  "name": "div32"     },
            { "value": SDIV32, "name": "sdiv32"    },
            { "value": MOD32,  "name": "divmod32"  },
            { "value": SMOD32, "name": "sdivmod32" },
            { "value": SHL32,  "name": "shl32"     },
            { "value": LSHR32, "name": "lshr32"    },
            { "value": ASHR32, "name": "ashr32"    },
            { "value": ADD,    "name": "add"       },
            { "value": SUB,    "name": "sub"       },
            { "value": MUL,    "name": "mul"       },
            { "value": DIV,    "name": "div"       },
            { "value": SDIV,   "name": "sdiv"      },
            { "value": MOD,    "name": "divmod"    },
            { "value": SMOD,   "name": "sdivmod"   },
            { "value": SHL,    "name": "shl"       },
            { "value": LSHR,   "name": "lshr"      },
            { "value": ASHR,   "name": "ashr"      },

            { "value": EQ,     "name": "eq"        },
            { "value": NEQ,    "name": "neq"       },
            { "value": GE,     "name": "ge"        },
            { "value": LE,     "name": "le"        },
            { "value": GT,     "name": "gt"        },
            { "value": LT,     "name": "lt"        },
            { "value": SGE,    "name": "sge"       },
            { "value": SLE,    "name": "sle"       },
            { "value": SGT,    "name": "sgt"       },
            { "value": SLT,    "name": "slt"       },
        ].each {
            var key = _1;
            lexer_.addKeyword(_1.name, CMD) { &(yylval, token)
                yylval.value = key.value;
                yylval.name = key.name;
                return token;
            };
        };

        lexer_.addRule(/\br([0-9]+)\b/, RREG) { &(value)
            return Integer.parseInt(value.subString(1));
        };
        lexer_.addRule(/\bs([0-9]+)\b/, SREG) { &(value)
            return Integer.parseInt(value.subString(1));
        };
        lexer_.addRule(/"([^\"]|\\.)*"/, STR) { &(value)
            return value.subString(1, value.length() - 2).replace(/\\(.)/, &(g) => {
                var c = g[1].string;
                if (c == 'n') {
                    return '\n';
                }
                if (c == 'r') {
                    return '\r';
                }
                if (c == 't') {
                    return '\t';
                }
                return c;
            });
        };
        lexer_.addRule(/\b[_a-zA-Z][_a-zA-Z0-9]*\b/, LABEL);
        lexer_.addRule(/0b[0-9a-fA-F]+|0x[0-9a-fA-F]+|0[0-7]*/, INT) { &(value)
            return Integer.parseInt(value);
        };
        lexer_.addRule(/[1-9][0-9]*(\.[0-9]+([eE][-+]?[0-9]+)?)?/) { &(yylval)
            if (yylval.value.find(".") > 0 || yylval.value.find("e") > 0 || yylval.value.find("E") > 0) {
                yylval.value = Double.parseDouble(yylval.value);
                return DBL;
            }
            yylval.value = Integer.parseInt(yylval.value);
            return INT;
        };
        if (opts_.debug.lexer) {
            lexer_.debugOn(lexer_.DEBUG_TOKEN|lexer_.DEBUG_VALUE);
        }
    }

    private get(val) {
        if (val.type == "A") {
            if (data_[val.name].isUndefined) {
                throw RuntimeException("Undefined data: " + val.name);
            }
            return data_[val.name];
        }
        if (val.type == "I" || val.type == "D") {
            return Jit.IMM(val.v);
        }
        if (val.type == "R" || val.type == "S") {
            var r = regs_[val.type][val.n];
            if (r.isUndefined) {
                throw RuntimeException("Invalid register");
            }
            return r;
        }
        if (val.type == "DR" || val.type == "DS") {
            var r = regs_[val.type == "DR" ? "R" : "S"][val.n];
            if (r.isUndefined) {
                throw RuntimeException("Invalid register");
            }
            return Jit.MEM1(r, val.offset);
        }
        throw RuntimeException("Invalid operand");
    }

    private comp(c, cmd, label, op1, op2) {
        var target = c[cmd](get(op1), get(op2));
        var jumpto = entries_[funcname_].labels[label];
        if (jumpto) {
            target.setLabel(jumpto);
        } else {
            pendings_.push((&(funcname, label, target) => {
                return function() {
                    var jumpto = entries_[funcname].labels[label];
                    if (jumpto.isUndefined) {
                        throw RuntimeException("Label not found: " + label + " in " + funcname);
                    }
                    target.setLabel(jumpto);
                };
            })(funcname_, label, target));
        }
    }

    private gen1(c, cmd, op1) {
        c[cmd](get(op1));
    }

    private gen2(c, cmd, op1, op2) {
        c[cmd](get(op1), get(op2));
    }

    private gen3(c, cmd, op1, op2, op3) {
        c[cmd](get(op1), get(op2), get(op3));
    }

    private checkOprands(line, count) {
        var opslen = line.operand.length();
        if (opslen < count) {
            System.println("Operands are not enough at line %{line.line}");
            error_ = true;
        }
        if (opslen > count) {
            System.println("Too many operands at line %{line.line}");
            error_ = true;
        }
    }

    private jitCompile(list) {
        // list.each { System.println(_1.toJsonString()); };
        // return;

        var c = new Jit.Compiler();
        list.each {
            var ops = _1.operand;
            var op0 = ops[0];
            switch (_1.cmd) {
            case LOAD:
                if (op0.type == LIB) {
                    Jit.Clib.addlib(op0.name);
                } else if (op0.type == FUNC) {
                    loaded_[op0.name] = Jit.Clib.load(op0.name);
                    if (!loaded_[op0.name]) {
                        throw RuntimeException("Loading a function failed: " + op0.name);
                    }
                } else {
                    throw RuntimeException("Invalid load type");
                }
                break;
            case DATA:
                if (op0.value.isString || op0.value.isBinary) {
                    data_[op0.name] = op0.value;
                } else {
                    throw RuntimeException("Invalid data type");
                }
                break;

            case FUNC:
                funcname_ = op0.name;
                if (entries_[funcname_].entry.isDefined) {
                    throw RuntimeException("Duplicated function name");
                }
                entries_[funcname_].entry = c.enter();
                entries_[funcname_].labels = {};
                break;
            case LABEL:
                if (entries_[funcname_].labels[op0.name].isUndefined) {
                    entries_[funcname_].labels[op0.name] = c.label();
                }
                break;

            case JMP:
                checkOprands(_1, 1);
                var jumpto = entries_[funcname_].labels[op0.name];
                if (jumpto) {
                    c.jump(jumpto);
                } else {
                    var target = c.jmp();
                    pendings_.push((&(funcname, label, target) => {
                        return function() {
                            var jumpto = entries_[funcname].labels[label];
                            if (jumpto.isUndefined) {
                                throw RuntimeException("Label not found: " + label + " in " + funcname);
                            }
                            target.setLabel(jumpto);
                        };
                    })(funcname_, op0.name, target));
                }
                break;
            case CALL:
                checkOprands(_1, 1);
                if (loaded_[op0.name]) {
                    c.icall(loaded_[op0.name]);
                } else {
                    var entry = entries_[op0.name].entry;
                    if (entry) {
                        c.call(entry);
                    } else {
                        var target = c.call();
                        pendings_.push((&(name, target) => {
                            return function() {
                                if (entries_[name].entry.isUndefined) {
                                    throw RuntimeException("Function not found: " + name);
                                }
                                target.setLabel(entries_[name].entry);
                            };
                        })(op0.name, target));
                    }
                }
                break;

            case RET:
                gen1(c, _1.name, ops[0] ?? { type: "R", n: 0 });
                break;

            case ADD32:
            case SUB32:
            case MUL32:
            case DIV32:
            case SDIV32:
            case MOD32:
            case SMOD32:
            case ADD:
            case SUB:
            case DIV:
            case SDIV:
            case MOD:
            case SMOD:
            case MUL:
                checkOprands(_1, 3);
                gen3(c, _1.name, ops[0], ops[1], ops[2]);
                break;

            case EQ:
            case NEQ:
            case GE:
            case LE:
            case GT:
            case LT:
            case SGE:
            case SLE:
            case SGT:
            case SLT:
                checkOprands(_1, 3);
                comp(c, _1.name, op0.name, ops[1], ops[2]);
                break;

            case NEG32:
            case CLZ32:
            case NOT32:
            case NEG:
            case CLZ:
            case NOT:
                checkOprands(_1, 1);
                gen1(c, _1.name, ops[0]);
                break;

            case MOV8S:
            case MOV16S:
            case MOV32S:
            case MOV8:
            case MOV16:
            case MOV32:
            case FMOV32:
            case FMOV:
            case AND32:
            case OR32:
            case XOR32:
            case SHL32:
            case LSHR32:
            case ASHR32:
            case MOV:
            case AND:
            case OR:
            case XOR:
            case SHL:
            case LSHR:
            case ASHR:
                checkOprands(_1, 2);
                gen2(c, _1.name, ops[0], ops[1]);
                break;

            default:
                break;
            }
        };

        pendings_.each { => _1() };
        return c.generate();
    }

    public dump(list) {
        if (!code_) {
            code_ = jitCompile(list);
        }
        code_.dump();
        return 0;
    }

    public run(list) {
        if (!code_) {
            code_ = jitCompile(list);
        }
        return code_.run();
    }

    public parse(asmcode) {
        entries_ = [];
        pendings_ = [];
        error_ = false;

        /* Parser */
        var lineNumber = 1;
        var parser = new Kacc.Parser(lexer_, {
            yyerror: &(msg) => {
                System.println(("ERROR! " + msg + " at line %{lineNumber}").red().bold());
                error_ = true;
            },
            nextLine: &() => {
                ++lineNumber;
            },
            getLine: &() => {
                return lineNumber;
            },
        });

        var ret;
        parser.parse(asmcode.trimRight() + '\n', { &(r)
            ret = r;
        });

        if (!error_) {
            return ret;
        }
    }

}
