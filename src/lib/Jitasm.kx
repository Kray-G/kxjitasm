#line 1 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

#line 3 "src/lib/jitasm.y"

using @kacc.Lexer;
#line 7 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

const YYERRTOK = 256;
const CMD = 257;
const FUNC = 258;
const LABEL = 259;
const JMP = 260;
const CALL = 261;
const RET = 262;
const MOV = 263;
const NEG = 264;
const CLZ = 265;
const ADD = 266;
const SUB = 267;
const MUL = 268;
const DIV = 269;
const SDIV = 270;
const MOD = 271;
const SMOD = 272;
const NOT = 273;
const AND = 274;
const OR = 275;
const XOR = 276;
const SHL = 277;
const LSHR = 278;
const ASHR = 279;
const EQ = 280;
const NEQ = 281;
const GE = 282;
const LE = 283;
const GT = 284;
const LT = 285;
const SGE = 286;
const SLE = 287;
const SGT = 288;
const SLT = 289;
const SREG = 290;
const RREG = 291;
const VAR = 292;
const ARG = 293;
const INT = 294;
const DBL = 295;
#line 11 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

#line 13 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
namespace Kacc {
#line 18 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

/* Prototype file of Kinx parser.
 * Written by Kray-G
 * This file is PUBLIC DOMAIN.
 */

class Parser(lexer_, opts_) {

    /*
    #define yyclearin (yychar = -1)
    #define yyerrok (yyerrflag = 0)
    #define YYRECOVERING (yyerrflag != 0)
    #define YYERROR  goto yyerrlab
    */

    var value_;
    var yyerror = opts_.yyerror ?? System.println;

    private initialize() {
        opts_.keySet().each {
            if (opts_[_1].isFunction) {
                this[_1] = opts_[_1];
            }
        };
    }

    private yyprintln(msg) {
        System.println(msg);
    }

    /* Debug mode flag */
#line 50 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    @yydebug = false;
#line 52 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

#line 110 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

    const yytranslate = [
            0,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           10,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   12,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   11,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   13,   15,   14,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,    1,    2,   15,    3,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
           15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
            4,    5,    6,    7,    8,    9
#line 113 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const YYBADCH = 15;
    const YYMAXLEX = 296;
    const YYTERMS = 15;
    const YYNONTERMS = 7;

    const yyaction = [
           33,   27,   28,    7,    8,   29,   30,    4,    1,    5,
           -1,    0,   14,   15,   11,   12,    0,   22,   20,   21,
            0,    0,    0,    0,    2,    0,   13,    0,   31,   32
#line 122 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const YYLAST = 30;

    const yycheck = [
            3,    4,    5,    6,    7,    8,    9,    1,    2,    3,
            0,    0,    8,    8,   11,   13,   -1,   10,   10,   10,
           -1,   -1,   -1,   -1,   12,   -1,   13,   -1,   14,   14
#line 128 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const yybase = [
            6,   -3,   -3,   10,    7,    3,   11,    2,   13,    8,
           12,    9,    4,    5,   14,   15,    0,    0,    0,    6
#line 132 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const YY2TBLSTATE = 4;

    const yydefault = [
        32767,    7,32767,32767,32767,32767,32767,32767,32767,32767,
            8,32767,32767,32767,32767,32767
#line 138 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const yygoto = [
           26,    0,   19
#line 142 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const YYGLAST = 3;

    const yygcheck = [
            6,   -1,    3
#line 148 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const yygbase = [
            0,    0,    0,   -1,    0,    0,   -2
#line 152 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const yygdefault = [
        -32768,    6,    3,   18,    9,   10,   25
#line 156 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const yylhs = [
            0,    1,    2,    2,    3,    3,    3,    4,    4,    5,
            5,    6,    6,    6,    6,    6,    6,    6
#line 160 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const yylen = [
            1,    1,    1,    2,    3,    3,    2,    0,    1,    1,
            3,    1,    1,    1,    1,    4,    4,    1
#line 164 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
    ];

    const YYSTATES = 30;
    const YYNLSTATES = 16;
    const YYINTERRTOK = 1;
    const YYUNEXPECTED = 32767;
    const YYDEFAULT = -32766;

    var yylex = lexer_.yylex;

    /*
     * Parser entry point
     */
    private yyparse() {
        var yyastk = [];
        var yysstk = [];
        var yylval, yyn, yysp = 0;
        var yyerrflag = 0;
        var yyval;

        yystate = 0;
        yychar = -1;
        yysstk[yysp] = 0;

        while (true) {
#line 192 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
            if (yybase[yystate] == 0)
                yyn = yydefault[yystate];
            else {
                if (yychar < 0) {
                    yylval = {};
                    if ((yychar = yylex(yylval)) <= 0) yychar = 0;
                    yychar = yychar < YYMAXLEX ? yytranslate[yychar] : YYBADCH;
#line 202 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                }

                if (((yyn = yybase[yystate] + yychar) >= 0
                    && yyn < YYLAST && yycheck[yyn] == yychar
                    || (yystate < YY2TBLSTATE
                        && (yyn = yybase[yystate + YYNLSTATES] + yychar) >= 0
                        && yyn < YYLAST && yycheck[yyn] == yychar))
                    && (yyn = yyaction[yyn]) != YYDEFAULT) {
                    /*
                     * >= YYNLSTATE: shift and reduce
                     * > 0: shift
                     * = 0: accept
                     * < 0: reduce
                     * = -YYUNEXPECTED: error
                     */
                    if (yyn > 0) {
                        /* shift */
#line 222 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                        yysp++;

                        yysstk[yysp] = yystate = yyn;
                        yyastk[yysp] = yylval;
                        yychar = -1;

                        if (yyerrflag > 0)
                            yyerrflag--;
                        if (yyn < YYNLSTATES)
                            continue;

                        /* yyn >= YYNLSTATES means shift-and-reduce */
                        yyn -= YYNLSTATES;
                    } else {
                        yyn = -yyn;
                    }
                } else {
                    yyn = yydefault[yystate];
                }
            }

            while (true) {
                /* reduce/error */
                if (yyn == 0) {
                    /* accept */
#line 250 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                    value_ = yyastk[yysp];
                    return 0;
                } else if (yyn != YYUNEXPECTED) {
                    /* reduce */
                    yyl = yylen[yyn];
                    yyval = yyastk[yysp-yyl+1];
#line 259 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                    /* Following line will be replaced by reduce actions */
                    switch(yyn) {
                    case 2:
#line 21 "src/lib/jitasm.y"
{ yyval = [yyastk[yysp-(1-1)]]; } break;
                    case 3:
#line 22 "src/lib/jitasm.y"
{ yyval.push(yyastk[yysp-(2-2)]); } break;
                    case 4:
#line 26 "src/lib/jitasm.y"
{ yyval = { "cmd": yyastk[yysp-(3-1)].value, "name": yyastk[yysp-(3-1)].name, "operand": yyastk[yysp-(3-2)] }; } break;
                    case 5:
#line 27 "src/lib/jitasm.y"
{ yyval = { "cmd": LABEL, "name": "label", "operand": [{ "name": yyastk[yysp-(3-1)].value }] }; } break;
                    case 6:
#line 28 "src/lib/jitasm.y"
{ yyval.error = true; } break;
                    case 7:
#line 32 "src/lib/jitasm.y"
{ yyval = []; } break;
                    case 9:
#line 37 "src/lib/jitasm.y"
{ yyval = [yyastk[yysp-(1-1)]]; } break;
                    case 10:
#line 38 "src/lib/jitasm.y"
{ yyval.push(yyastk[yysp-(3-3)]); } break;
                    case 11:
#line 42 "src/lib/jitasm.y"
{ yyval = { "type": "S", "n": yyastk[yysp-(1-1)].value }; } break;
                    case 12:
#line 43 "src/lib/jitasm.y"
{ yyval = { "type": "R", "n": yyastk[yysp-(1-1)].value }; } break;
                    case 13:
#line 44 "src/lib/jitasm.y"
{ yyval = { "type": "I", "v": yyastk[yysp-(1-1)].value }; } break;
                    case 14:
#line 45 "src/lib/jitasm.y"
{ yyval = { "type": "D", "v": yyastk[yysp-(1-1)].value }; } break;
                    case 15:
#line 46 "src/lib/jitasm.y"
{ yyval = { "type": "V", "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 16:
#line 47 "src/lib/jitasm.y"
{ yyval = { "type": "A", "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 17:
#line 48 "src/lib/jitasm.y"
{ yyval = { "type": "L", "name": yyastk[yysp-(1-1)].value }; } break;
#line 265 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                    }
                    /* Goto - shift nonterminal */
                    yysp -= yyl;
                    yyn = yylhs[yyn];
                    if ((yyp = yygbase[yyn] + yysstk[yysp]) >= 0 && yyp < YYGLAST && yygcheck[yyp] == yyn)
                        yystate = yygoto[yyp];
                    else
                        yystate = yygdefault[yyn];

                    yysp++;

                    yysstk[yysp] = yystate;
                    yyastk[yysp] = yyval;
                } else {
                    /* error */
                    switch (yyerrflag) {
                    case 0:
                        yyerror("syntax error");
                    case 1:
                    case 2:
                        yyerrflag = 3;
                        /* Pop until error-expecting state uncovered */

                        while (!((yyn = yybase[yystate] + YYINTERRTOK) >= 0
                            && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK
                            || (yystate < YY2TBLSTATE
                                && (yyn = yybase[yystate + YYNLSTATES] + YYINTERRTOK) >= 0
                                && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK))) {
                            if (yysp <= 0) {
                                return 1;
                            }
                            yystate = yysstk[--yysp];
#line 300 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                        }
                        yyn = yyaction[yyn];
#line 305 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                        yysstk[++yysp] = yystate = yyn;
                        break;

                    case 3:
#line 312 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
                        if (yychar == 0) {
                            return 1;
                        }
                        yychar = -1;
                        break;
                    }
                }

                if (yystate < YYNLSTATES)
                    break;
                /* >= YYNLSTATES means shift-and-reduce */
                yyn = yystate - YYNLSTATES;
            }
        }
    }

    this.parse = _function(text, successCallback, failureCallback) {
        lexer_.reset(text);
        if (yyparse() == 0) {
            successCallback(value_);
        } else {
            failureCallback(value_);
        }
    };

}

#line 340 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"
} // namespace Kacc
#line 345 "C:/Users/nagai.kazuya/scoop/apps/kinx/current/lib/package/kacc/99.99.99/etc/kmyacc.kx.parser"

#line 52 "src/lib/jitasm.y"

/* Lexical analyzer */
Jitasm.lexer = new Kacc.Lexer();
Jitasm.lexer.addSkip(/[ \t\r]+|#[^\r\n]+/);
[
    { "value": FUNC, "name": "func" },
    { "value": JMP,  "name": "jmp"  },
    { "value": CALL, "name": "call" },
    { "value": RET,  "name": "ret"  },
    { "value": MOV,  "name": "mov"  },
    { "value": NEG,  "name": "neg"  },
    { "value": CLZ,  "name": "clz"  },
    { "value": ADD,  "name": "add"  },
    { "value": SUB,  "name": "sub"  },
    { "value": MUL,  "name": "mul"  },
    { "value": DIV,  "name": "div"  },
    { "value": SDIV, "name": "sdiv" },
    { "value": MOD,  "name": "mod"  },
    { "value": SMOD, "name": "smod" },
    { "value": MOD,  "name": "mod"  },
    { "value": SHL,  "name": "shl"  },
    { "value": LSHR, "name": "lshr" },
    { "value": ASHR, "name": "ashr" },
    { "value": EQ,   "name": "eq"   },
    { "value": NEQ,  "name": "neq"  },
    { "value": GE,   "name": "ge"   },
    { "value": LE,   "name": "le"   },
    { "value": GT,   "name": "gt"   },
    { "value": LT,   "name": "lt"   },
    { "value": SGE,  "name": "sge"  },
    { "value": SLE,  "name": "sle"  },
    { "value": SGT,  "name": "sgt"  },
    { "value": SLT,  "name": "slt"  },
].each {
    var key = _1;
    Jitasm.lexer.addKeyword(_1.name, CMD) { &(yylval, token)
        yylval.value = key.value;
        yylval.name = key.name;
        return token;
    };
};

Jitasm.lexer.addRule(/var/, VAR);
Jitasm.lexer.addRule(/arg/, ARG);
Jitasm.lexer.addRule(/\br([0-9]+)\b/, RREG) { &(value)
    return Integer.parseInt(value.subString(1));
};
Jitasm.lexer.addRule(/\bs([0-9]+)\b/, SREG) { &(value)
    return Integer.parseInt(value.subString(1));
};
Jitasm.lexer.addRule(/\b[a-zA-Z][a-zA-Z0-9]*\b/, LABEL);
Jitasm.lexer.addRule(/[0-9]+(\.[0-9]+([eE][-+]?[0-9]+)?)?/) { &(yylval)
    if (yylval.value.find(".") > 0 || yylval.value.find("e") > 0 || yylval.value.find("E") > 0) {
        yylval.value = Double.parseDouble(yylval.value);
        return DBL;
    }
    yylval.value = Integer.parseInt(yylval.value);
    return INT;
};

using @jitasm._JitasmBase;

