

using @kacc.Lexer;

const YYERRTOK = 256;
const CMD = 257;
const FUNC = 258;
const LABEL = 259;
const IF = 260;
const JMP = 261;
const CALL = 262;
const RET = 263;
const MOV = 264;
const NEG = 265;
const CLZ = 266;
const ADD = 267;
const SUB = 268;
const MUL = 269;
const DIV = 270;
const SDIV = 271;
const MOD = 272;
const SMOD = 273;
const NOT = 274;
const AND = 275;
const OR = 276;
const XOR = 277;
const SHL = 278;
const LSHR = 279;
const ASHR = 280;
const EQ = 281;
const NEQ = 282;
const GE = 283;
const LE = 284;
const GT = 285;
const LT = 286;
const SGE = 287;
const SLE = 288;
const SGT = 289;
const SLT = 290;
const SREG = 291;
const RREG = 292;
const VAR = 293;
const ARG = 294;
const INT = 295;
const DBL = 296;
const SW = 297;
const FP = 298;
const SIGNED = 299;
const OPEQ = 300;
const OPNEQ = 301;
const OPGE = 302;
const OPLE = 303;

namespace Kacc {

/* Prototype file of Kinx parser.
 * Written by Kray-G
 * This file is PUBLIC DOMAIN.
 */

class Parser(lexer_, opts_) {

    /*
    #define yyclearin (yychar = -1)
    #define yyerrok (yyerrflag = 0)
    #define YYRECOVERING (yyerrflag != 0)
    #define YYERROR  goto yyerrlab
    */

    var value_;
    var yyerror = opts_.yyerror ?? System.println;

    private initialize() {
        opts_.keySet().each {
            if (opts_[_1].isFunction) {
                this[_1] = opts_[_1];
            }
        };
    }

    private yyprintln(msg) {
        System.println(msg);
    }

    /* Debug mode flag */
    @yydebug = false;


    const yytranslate = [
            0,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           18,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   20,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   19,   25,
           24,   25,   23,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   21,   25,   22,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,    1,    2,    3,    4,
            5,    6,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
           25,    7,    8,    9,   10,   11,   12,   25,   25,   13,
           14,   15,   16,   17
    ];

    const YYBADCH = 25;
    const YYMAXLEX = 304;
    const YYTERMS = 25;
    const YYNONTERMS = 8;

    const yyaction = [
           18,    3,   19,   20,    2,   21,   76,   -1,    0,   70,
           71,   24,   25,   72,   73,   83,   82,   59,    6,    7,
            8,    9,   12,   13,   84,   80,   79,   10,   11,   14,
           15,   78,   85,   86,   77,   81,   28,   30,    4,    5,
           47,   48,   49,   50,   51,   52,   53,   54,   45,   46,
            0,    0,    0,    0,    0,   33,   34,    0,    0,    0,
            0,    0,    0,    0,   63,   60,   61,   62,   64,   65,
            0,   29,    0,    0,   31,   32,    0,   74,   75
    ];

    const YYLAST = 79;

    const yycheck = [
            1,    2,    3,    4,    5,    6,    4,    0,    0,    7,
            8,    9,   10,   11,   12,    4,    4,   18,   14,   15,
           16,   17,   16,   17,    4,    4,    4,   23,   24,   23,
           24,    4,    4,    4,    4,    4,    4,    4,   13,   20,
            6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
           -1,   -1,   -1,   -1,   -1,   11,   11,   -1,   -1,   -1,
           -1,   -1,   -1,   -1,   18,   18,   18,   18,   18,   18,
           -1,   19,   -1,   -1,   21,   21,   -1,   22,   22
    ];

    const yybase = [
           -1,    7,   25,    2,    2,    2,    2,    2,    2,    2,
            2,    2,    2,    2,    2,    2,    4,    6,   51,   32,
           52,   33,    8,   50,   53,   54,   49,   19,   48,   47,
           46,   44,   45,   55,   56,   42,   43,   34,   35,   36,
           37,   38,   39,   40,   41,   30,   27,   22,   21,   31,
           12,   11,   20,   28,   29,    0,   -1,    2
    ];

    const YY2TBLSTATE = 3;

    const yydefault = [
        32767,32767,32767,   11,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,   12,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,
        32767,32767,32767,32767,32767
    ];

    const yygoto = [
           68,   17,   69,   35,   36,   37,   38,   39,   40,   41,
           42,   43,   44,   58
    ];

    const YYGLAST = 14;

    const yygcheck = [
            7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
            7,    7,    7,    3
    ];

    const yygbase = [
            0,    0,    0,   12,    0,    0,    0,   -3
    ];

    const yygdefault = [
        -32768,   22,    1,   57,   26,   23,   27,   16
    ];

    const yylhs = [
            0,    1,    2,    2,    3,    3,    3,    3,    3,    3,
            3,    4,    4,    6,    6,    7,    7,    7,    7,    7,
            7,    7,    5,    5,    5,    5,    5,    5,    5,    5,
            5,    5
    ];

    const yylen = [
            1,    1,    1,    2,    1,    3,    3,    3,    3,    2,
            2,    0,    1,    1,    3,    1,    1,    1,    1,    4,
            4,    1,    6,    6,    6,    6,    6,    6,    7,    7,
            7,    7
    ];

    const YYSTATES = 83;
    const YYNLSTATES = 55;
    const YYINTERRTOK = 1;
    const YYUNEXPECTED = 32767;
    const YYDEFAULT = -32766;

    var yylex = lexer_.yylex;

    /*
     * Parser entry point
     */
    private yyparse() {
        var yyastk = [];
        var yysstk = [];
        var yylval, yyn, yysp = 0;
        var yyerrflag = 0;
        var yyval;

        yystate = 0;
        yychar = -1;
        yysstk[yysp] = 0;

        while (true) {
            if (yybase[yystate] == 0)
                yyn = yydefault[yystate];
            else {
                if (yychar < 0) {
                    yylval = {};
                    if ((yychar = yylex(yylval)) <= 0) yychar = 0;
                    yychar = yychar < YYMAXLEX ? yytranslate[yychar] : YYBADCH;
                }

                if (((yyn = yybase[yystate] + yychar) >= 0
                    && yyn < YYLAST && yycheck[yyn] == yychar
                    || (yystate < YY2TBLSTATE
                        && (yyn = yybase[yystate + YYNLSTATES] + yychar) >= 0
                        && yyn < YYLAST && yycheck[yyn] == yychar))
                    && (yyn = yyaction[yyn]) != YYDEFAULT) {
                    /*
                     * >= YYNLSTATE: shift and reduce
                     * > 0: shift
                     * = 0: accept
                     * < 0: reduce
                     * = -YYUNEXPECTED: error
                     */
                    if (yyn > 0) {
                        /* shift */
                        yysp++;

                        yysstk[yysp] = yystate = yyn;
                        yyastk[yysp] = yylval;
                        yychar = -1;

                        if (yyerrflag > 0)
                            yyerrflag--;
                        if (yyn < YYNLSTATES)
                            continue;

                        /* yyn >= YYNLSTATES means shift-and-reduce */
                        yyn -= YYNLSTATES;
                    } else {
                        yyn = -yyn;
                    }
                } else {
                    yyn = yydefault[yystate];
                }
            }

            while (true) {
                /* reduce/error */
                if (yyn == 0) {
                    /* accept */
                    value_ = yyastk[yysp];
                    return 0;
                } else if (yyn != YYUNEXPECTED) {
                    /* reduce */
                    yyl = yylen[yyn];
                    yyval = yyastk[yysp-yyl+1];
                    /* Following line will be replaced by reduce actions */
                    switch(yyn) {
                    case 2:
{ yyastk[yysp-(1-1)].line = @getLine(); yyval = [yyastk[yysp-(1-1)]]; @nextLine(); } break;
                    case 3:
{ yyastk[yysp-(2-2)].line = @getLine(); if (yyastk[yysp-(2-2)].isDefined) yyval.push(yyastk[yysp-(2-2)]); @nextLine(); } break;
                    case 4:
{ yyval = null; } break;
                    case 5:
{ yyval = { "cmd": LABEL, "name": "label", "operand": [{ "name": yyastk[yysp-(3-1)].value }] }; } break;
                    case 6:
{ yyval = { "cmd": FUNC, "name": "func", "operand": [{ "name": yyastk[yysp-(3-2)].value }] }; } break;
                    case 7:
{ yyval = { "cmd": yyastk[yysp-(3-1)].value, "name": yyastk[yysp-(3-1)].name, "operand": yyastk[yysp-(3-2)] }; } break;
                    case 8:
{ yyval = { "cmd": JMP, "name": "jmp", "operand": [{ "name": yyastk[yysp-(3-2)].value }] }; } break;
                    case 10:
{ yyval.error = true; } break;
                    case 11:
{ yyval = []; } break;
                    case 13:
{ yyval = [yyastk[yysp-(1-1)]]; } break;
                    case 14:
{ yyval.push(yyastk[yysp-(3-3)]); } break;
                    case 15:
{ yyval = { "type": "S", "n": yyastk[yysp-(1-1)].value }; } break;
                    case 16:
{ yyval = { "type": "R", "n": yyastk[yysp-(1-1)].value }; } break;
                    case 17:
{ yyval = { "type": "I", "v": yyastk[yysp-(1-1)].value }; } break;
                    case 18:
{ yyval = { "type": "D", "v": yyastk[yysp-(1-1)].value }; } break;
                    case 19:
{ yyval = { "type": "V", "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 20:
{ yyval = { "type": "A", "offset": yyastk[yysp-(4-3)].value }; } break;
                    case 21:
{ yyval = { "type": "L", "name": yyastk[yysp-(1-1)].value }; } break;
                    case 22:
{ yyval = { "cmd": EQ, "name": "eq", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 23:
{ yyval = { "cmd": NEQ, "name": "neq", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 24:
{ yyval = { "cmd": GE, "name": "ge", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 25:
{ yyval = { "cmd": LE, "name": "le", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 26:
{ yyval = { "cmd": GT, "name": "gt", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 27:
{ yyval = { "cmd": LT, "name": "lt", "operand": [{ "type": "L", "name": yyastk[yysp-(6-6)].value }, yyastk[yysp-(6-2)], yyastk[yysp-(6-4)]] }; } break;
                    case 28:
{ yyval = { "cmd": SGE, "name": "sge", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    case 29:
{ yyval = { "cmd": SLE, "name": "sle", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    case 30:
{ yyval = { "cmd": SGT, "name": "sgt", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    case 31:
{ yyval = { "cmd": SLT, "name": "slt", "operand": [{ "type": "L", "name": yyastk[yysp-(7-7)].value }, yyastk[yysp-(7-3)], yyastk[yysp-(7-5)]] }; } break;
                    }
                    /* Goto - shift nonterminal */
                    yysp -= yyl;
                    yyn = yylhs[yyn];
                    if ((yyp = yygbase[yyn] + yysstk[yysp]) >= 0 && yyp < YYGLAST && yygcheck[yyp] == yyn)
                        yystate = yygoto[yyp];
                    else
                        yystate = yygdefault[yyn];

                    yysp++;

                    yysstk[yysp] = yystate;
                    yyastk[yysp] = yyval;
                } else {
                    /* error */
                    switch (yyerrflag) {
                    case 0:
                        yyerror("syntax error");
                    case 1:
                    case 2:
                        yyerrflag = 3;
                        /* Pop until error-expecting state uncovered */

                        while (!((yyn = yybase[yystate] + YYINTERRTOK) >= 0
                            && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK
                            || (yystate < YY2TBLSTATE
                                && (yyn = yybase[yystate + YYNLSTATES] + YYINTERRTOK) >= 0
                                && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK))) {
                            if (yysp <= 0) {
                                return 1;
                            }
                            yystate = yysstk[--yysp];
                        }
                        yyn = yyaction[yyn];
                        yysstk[++yysp] = yystate = yyn;
                        break;

                    case 3:
                        if (yychar == 0) {
                            return 1;
                        }
                        yychar = -1;
                        break;
                    }
                }

                if (yystate < YYNLSTATES)
                    break;
                /* >= YYNLSTATES means shift-and-reduce */
                yyn = yystate - YYNLSTATES;
            }
        }
    }

    this.parse = _function(text, successCallback, failureCallback) {
        lexer_.reset(text);
        if (yyparse() == 0) {
            successCallback(value_);
        } else {
            failureCallback(value_);
        }
    };

}

} // namespace Kacc


/* Lexical analyzer */
Jitasm.lexer = new Kacc.Lexer();
Jitasm.lexer.addSkip(/[ \t\r]+|#[^\r\n]+/);
Jitasm.lexer.addKeyword("==", OPEQ);
Jitasm.lexer.addKeyword("!=", OPNEQ);
Jitasm.lexer.addKeyword(">=", OPGE);
Jitasm.lexer.addKeyword("<=", OPLE);
Jitasm.lexer.addKeyword("if", IF);
Jitasm.lexer.addKeyword("signed", SIGNED);
Jitasm.lexer.addKeyword("func", FUNC);
Jitasm.lexer.addKeyword("goto", JMP) { &(yylval, token)
    yylval.value = JMP;
    yylval.name = "jmp";
    return token;
};
[
    { "value": JMP,  "name": "jmp"  },
    { "value": CALL, "name": "call" },
    { "value": RET,  "name": "ret"  },
    { "value": MOV,  "name": "mov"  },
    { "value": NEG,  "name": "neg"  },
    { "value": CLZ,  "name": "clz"  },
    { "value": ADD,  "name": "add"  },
    { "value": SUB,  "name": "sub"  },
    { "value": MUL,  "name": "mul"  },
    { "value": DIV,  "name": "div"  },
    { "value": SDIV, "name": "sdiv" },
    { "value": MOD,  "name": "mod"  },
    { "value": SMOD, "name": "smod" },
    { "value": SHL,  "name": "shl"  },
    { "value": LSHR, "name": "lshr" },
    { "value": ASHR, "name": "ashr" },
    { "value": EQ,   "name": "eq"   },
    { "value": NEQ,  "name": "neq"  },
    { "value": GE,   "name": "ge"   },
    { "value": LE,   "name": "le"   },
    { "value": GT,   "name": "gt"   },
    { "value": LT,   "name": "lt"   },
    { "value": SGE,  "name": "sge"  },
    { "value": SLE,  "name": "sle"  },
    { "value": SGT,  "name": "sgt"  },
    { "value": SLT,  "name": "slt"  },
].each {
    var key = _1;
    Jitasm.lexer.addKeyword(_1.name, CMD) { &(yylval, token)
        yylval.value = key.value;
        yylval.name = key.name;
        return token;
    };
};

Jitasm.lexer.addRule(/var/, VAR);
Jitasm.lexer.addRule(/arg/, ARG);
Jitasm.lexer.addRule(/\br([0-9]+)\b/, RREG) { &(value)
    return Integer.parseInt(value.subString(1));
};
Jitasm.lexer.addRule(/\bs([0-9]+)\b/, SREG) { &(value)
    return Integer.parseInt(value.subString(1));
};
Jitasm.lexer.addRule(/\b[_a-zA-Z][_a-zA-Z0-9]*\b/, LABEL);
Jitasm.lexer.addRule(/[0-9]+(\.[0-9]+([eE][-+]?[0-9]+)?)?/) { &(yylval)
    if (yylval.value.find(".") > 0 || yylval.value.find("e") > 0 || yylval.value.find("E") > 0) {
        yylval.value = Double.parseDouble(yylval.value);
        return DBL;
    }
    yylval.value = Integer.parseInt(yylval.value);
    return INT;
};
// Jitasm.lexer.debugOn(Jitasm.lexer.DEBUG_TOKEN|Jitasm.lexer.DEBUG_VALUE);

using Jit;

class Jitasm(lexer_) {
    lexer_ ??= Jitasm.lexer;
    var labels_, pendings_, error_;
    var regs_ = {
        "R": [Jit.R0, Jit.R1, Jit.R2, Jit.R3, Jit.R4, Jit.R5],
        "S": [Jit.S0, Jit.S1, Jit.S2, Jit.S3, Jit.S4, Jit.S5],
        "FR": [Jit.FR0, Jit.FR1, Jit.FR2, Jit.FR3, Jit.FR4, Jit.FR5],
        "FS": [Jit.FS0, Jit.FS1, Jit.FS2, Jit.FS3, Jit.FS4, Jit.FS5],
    };

    private get(val) {
        if (val.type == "R" || val.type == "S") {
            var r = regs_[val.type][val.n];
            if (r.isUndefined) {
                throw RuntimeException("Invalid register");
            }
            return r;
        }
        if (val.type == "I") {
            return Jit.IMM(val.v);
        }
        throw RuntimeException("Invalid operand");
    }

    private comp(c, cmd, label, op1, op2) {
        var target = c[cmd](get(op1), get(op2));
        if (labels_[label].label) {
            target.setLabel(labels_[label].label);
        } else {
            pendings_.push((&(name, target) => {
                return function() {
                    if (labels_[name].label.isUndefined) {
                        throw RuntimeException("Function not found: " + name);
                    }
                    target.setLabel(labels_[name].label);
                };
            })(label, target));
        }
    }

    private calljmp(c, cmd, label, prop, msg) {
        if (labels_[label][prop]) {
            c[cmd](labels_[label][prop]);
        } else {
            var target = c[cmd]();
            pendings_.push((&(name, target) => {
                return function() {
                    if (labels_[name][prop].isUndefined) {
                        throw RuntimeException(msg);
                    }
                    target.setLabel(labels_[name][prop]);
                };
            })(label, target));
        }
    }

    private gen1(c, cmd, op1) {
        c[cmd](get(op1));
    }

    private gen2(c, cmd, op1, op2) {
        c[cmd](get(op1), get(op2));
    }

    private gen3(c, cmd, op1, op2, op3) {
        c[cmd](get(op1), get(op2), get(op3));
    }

    private checkOprands(line, count) {
        var opslen = line.operand.length();
        if (opslen < count) {
            System.println("Operands are not enough at line %{line.line}");
            error_ = true;
        }
        if (opslen > count) {
            System.println("Too many operands at line %{line.line}");
            error_ = true;
        }
    }

    private compile(list) {
        // list.each { System.println(_1.toJsonString()); };
        // return;

        var c = new Jit.Compiler();
        list.each {
            var ops = _1.operand;
            var op0 = ops[0];
            switch (_1.cmd) {
            case FUNC:
                if (labels_[op0.name].entry.isDefined) {
                    throw RuntimeException("Duplicated function name");
                }
                labels_[op0.name].entry = c.enter();
                break;
            case LABEL:
                if (labels_[op0.name].label.isUndefined) {
                    labels_[op0.name].label = c.label();
                }
                break;

            case JMP:
                checkOprands(_1, 1);
                calljmp(c, _1.name, op0.name, "label", "Label not found: " + op0.name);
                break;
            case CALL:
                checkOprands(_1, 1);
                calljmp(c, _1.name, op0.name, "entry", "Function not found: " + op0.name);
                break;

            case RET:
                gen1(c, _1.name, ops[0] ?? { type: "R", n: 0 });
                break;

            case ADD:
            case SUB:
            case MUL:
                checkOprands(_1, 3);
                gen3(c, _1.name, ops[0], ops[1], ops[2]);
                break;
            case DIV:
                checkOprands(_1, 0);
                c.div();
                break;
            case SDIV:
                checkOprands(_1, 0);
                c.sdiv();
                break;
            case MOD:
                checkOprands(_1, 0);
                c.divmod();
                break;
            case SMOD:
                checkOprands(_1, 0);
                c.sdivmod();
                break;

            case EQ:
            case NEQ:
            case GE:
            case LE:
            case GT:
            case LT:
            case SGE:
            case SLE:
            case SGT:
            case SLT:
                checkOprands(_1, 3);
                comp(c, _1.name, op0.name, ops[1], ops[2]);
                break;

            case NEG:
            case CLZ:
            case NOT:
                checkOprands(_1, 1);
                gen1(c, _1.name, ops[0]);
                break;

            case MOV:
            case AND:
            case OR:
            case XOR:
            case SHL:
            case LSHR:
            case ASHR:
                checkOprands(_1, 2);
                gen2(c, _1.name, ops[0], ops[1]);
                break;

            default:
                break;
            }
        };

        pendings_.each { => _1() };
        return c.generate();
    }

    public parse(asmcode) {
        labels_ = [];
        pendings_ = [];
        error_ = false;

        /* Parser */
        var lineNumber = 1;
        var parser = new Kacc.Parser(lexer_, {
            yyerror: &(msg) => {
                System.println(("ERROR! " + msg + " at line %{lineNumber}").red().bold());
                error_ = true;
            },
            nextLine: &() => {
                ++lineNumber;
            },
            getLine: &() => {
                return lineNumber;
            },
        });

        var ret;
        parser.parse(asmcode, { &(r)
            ret = r;
        });
        if (!error_) {
            ret = compile(ret);
        }
        if (!error_) {
            return ret;
        }
    }

}
